<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-05-26 Fri 10:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Theorem Proving in Lean</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://leodemoura.github.io][Leonardo de Moura]]Leonardo de Moura" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.23/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        :MMLYES: config: ["MMLorHTML.js"], jax: ["input/TeX"],
        :MMLNO: jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Theorem Proving in Lean</h1>

<div id="outline-container-org19f1d85" class="outline-2">
<h2 id="Inductive_Types"><a id="org19f1d85"></a><span class="section-number-2"> 6</span> Inductive Types</h2>
<div class="outline-text-2" id="text-Inductive_Types">
<p>
We have seen that Lean's formal foundation includes basic types,
<code>Prop, Type.{1}, Type.{2}, ...</code>, and allows for the formation of
dependent function types, <code>Π x : A. B</code>. In the examples, we have also
made use of additional types like <code>bool</code>, <code>nat</code>, and <code>int</code>, and type
constructors, like <code>list</code>, and product, <code>×</code>. In fact, in Lean's library,
every concrete type other than the universes and every type
constructor other than Pi is an instance of a general family of type
constructions known as <i>inductive types</i>. It is remarkable that it is
possible to construct a substantial edifice of mathematics based on
nothing more than the type universes, Pi types, and inductive types;
everything else follows from those.
</p>

<p>
Intuitively, an inductive type is built up from a specified list of
constructors. In Lean, the syntax for specifying such a type is as follows:
</p>
<div class="org-src-container">

<pre class="src src-text">inductive foo : Type :=
| constructor&#8321; : ... &#8594; foo
| constructor&#8322; : ... &#8594; foo
...
| constructor&#8345; : ... &#8594; foo
</pre>
</div>
<p>
The intuition is that each constructor specifies a way of building new
objects of <code>foo</code>, possibly from previously constructed values. The type
<code>foo</code> consists of nothing more than the objects that are constructed in
this way. The first character <code>|</code> in an inductive declaration is optional.
We can also separate constructors using a comma instead of <code>|</code>.
</p>

<p>
We will see below that the arguments to the constructors can include
objects of type <code>foo</code>, subject to a certain "positivity" constraint,
which guarantees that elements of <code>foo</code> are built from the bottom
up. Roughly speaking, each <code>...</code> can be any Pi type constructed from
<code>foo</code> and previously defined types, in which <code>foo</code> appears, if at all,
only as the "target" of the Pi type. For more details, see [<a href="#dybjer:94">1</a>].
</p>

<p>
We will provide a number of examples of inductive types. We will also
consider slight generalizations of the scheme above, to mutually
defined inductive types, and so-called <i>inductive families</i>.
</p>

<p>
As with the logical connectives, every inductive type comes with
introduction rules, which show how to construct an element of the
type, and elimination rules, which show how to "use" an element of the
type in another construction. The analogy to the logical connectives
should not come as a surprise; as we will see below, they, too, are
examples of inductive type constructions. You have already seen the
introduction rules for an inductive type: they are just the
constructors that are specified in the definition of the type. The
elimination rules provide for a principle of recursion on the type,
which includes, as a special case, a principle of induction as well.
</p>

<p>
In the next chapter, we will describe Lean's function definition
package, which provides even more convenient ways to define functions
on inductive types and carry out inductive proofs. But because the
notion of an inductive type is so fundamental, we feel it is important
to start with a low-level, hands-on understanding. We will start with
some basic examples of inductive types, and work our way up to more
elaborate and complex examples.
</p>
</div>

<div id="outline-container-org6d6ced8" class="outline-3">
<h3 id="org6d6ced8"><span class="section-number-3"> 6.1</span> Enumerated Types</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The simplest kind of inductive type is simply a type with a finite,
enumerated list of elements.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday
</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The <code>inductive</code> command creates a new type, <code>weekday</code>. The
constructors all live in the <code>weekday</code> namespace.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">check weekday.sunday
check weekday.monday

open weekday

check sunday
check monday</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

check weekday.sunday
check weekday.monday

open weekday

check sunday
check monday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Think of the <code>sunday</code>, <code>monday</code>, &#x2026; as being distinct elements of
<code>weekday</code>, with no other distinguishing properties. The elimination
principle, <code>weekday.rec</code>, is defined at the same time as the type
<code>weekday</code> and its constructors. It is also known as a <i>recursor</i>, and
it is what makes the type "inductive": it allows us to define a
function on <code>weekday</code> by assigning values corresponding to each
constructor. The intuition is that an inductive type is exhaustively
generated by the constructors, and has no elements beyond those they
construct.
</p>

<p>
We will use a slight (automatically generated) variant,
<code>weekday.rec_on</code>, which takes its arguments in a more convenient
order. Note that the shorter versions of names like <code>weekday.rec</code> and
<code>weekday.rec_on</code> are not made available by default when we open the
<code>weekday</code> namespace, to avoid clashes.  If we import <code>nat</code>, we can use
<code>rec_on</code> to define a function from weekday to the natural numbers:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">definition number_of_day (d : weekday) : nat :=
weekday.rec_on d 1 2 3 4 5 6 7

eval number_of_day weekday.sunday
eval number_of_day weekday.monday
eval number_of_day weekday.tuesday</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>import data.nat
open nat

inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

definition number_of_day (d : weekday) : nat :=
weekday.rec_on d 1 2 3 4 5 6 7

eval number_of_day weekday.sunday
eval number_of_day weekday.monday
eval number_of_day weekday.tuesday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The first (explicit) argument to <code>rec_on</code> is the element being "analyzed." The
next seven arguments are the values corresponding to the seven
constructors. Note that <code>number_of_day weekday.sunday</code> evaluates to
<code>1</code>: the computation rule for <code>rec_on</code> recognizes that <code>sunday</code> is a
constructor, and returns the appropriate argument.
</p>

<p>
Below we will encounter a more restricted variant of <code>rec_on</code>, namely,
<code>cases_on</code>. When it comes to enumerated types, <code>rec_on</code> and <code>cases_on</code>
are the same. You may prefer to use the label <code>cases_on</code>, because it
emphasizes that the definition is really a definition by cases.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">definition number_of_day (d : weekday) : nat :=
weekday.cases_on d 1 2 3 4 5 6 7</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>import data.nat
open nat

inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

definition number_of_day (d : weekday) : nat :=
weekday.cases_on d 1 2 3 4 5 6 7
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>

<p>
It is often useful to group definitions and theorems related to a
structure in a namespace with the same name. For example, we can put
the <code>number_of_day</code> function in the <code>weekday</code> namespace. We are then
allowed to use the shorter name when we open the namespace.
</p>

<p>
The names <code>rec_on</code>, <code>cases_on</code>, <code>induction_on</code>, and so on are
generated automatically. As noted above, they are <i>protected</i> to avoid
name clashes. In other words, they are not provided by default when
the namespace is opened. However, you can explicitly declare
abbreviations for them using the <code>renaming</code> option when you open a
namespace.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">namespace weekday
  local abbreviation cases_on := @weekday.cases_on

  definition number_of_day (d : weekday) : nat :=
  cases_on d 1 2 3 4 5 6 7
end weekday

eval weekday.number_of_day weekday.sunday

open weekday (renaming cases_on → cases_on)

eval number_of_day sunday
check cases_on</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>import data.nat
open nat

inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

namespace weekday
  local abbreviation cases_on := @weekday.cases_on

  definition number_of_day (d : weekday) : nat :=
  cases_on d 1 2 3 4 5 6 7
end weekday

eval weekday.number_of_day weekday.sunday

open weekday (renaming cases_on → cases_on)

eval number_of_day sunday
check cases_on
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can define functions from <code>weekday</code> to <code>weekday</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">namespace weekday
  definition next (d : weekday) : weekday :=
  weekday.cases_on d monday tuesday wednesday thursday friday saturday sunday

  definition previous (d : weekday) : weekday :=
  weekday.cases_on d saturday sunday monday tuesday wednesday thursday friday

  eval next (next tuesday)
  eval next (previous tuesday)

  example : next (previous tuesday) = tuesday := rfl
end weekday</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

namespace weekday
  definition next (d : weekday) : weekday :=
  weekday.cases_on d monday tuesday wednesday thursday friday saturday sunday

  definition previous (d : weekday) : weekday :=
  weekday.cases_on d saturday sunday monday tuesday wednesday thursday friday

  eval next (next tuesday)
  eval next (previous tuesday)

  example : next (previous tuesday) = tuesday := rfl
end weekday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>

<p>
How can we prove the general theorem that <code>next (previous d) = d</code> for
any weekday <code>d</code>? The induction principle parallels the recursion
principle: we simply have to provide a proof of the claim for each
constructor:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">  theorem next_previous (d: weekday) : next (previous d) = d :=
  weekday.induction_on d
    (show next (previous sunday) = sunday, from rfl)
    (show next (previous monday) = monday, from rfl)
    (show next (previous tuesday) = tuesday, from rfl)
    (show next (previous wednesday) = wednesday, from rfl)
    (show next (previous thursday) = thursday, from rfl)
    (show next (previous friday) = friday, from rfl)
    (show next (previous saturday) = saturday, from rfl)</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

namespace weekday
  definition next (d : weekday) : weekday :=
  weekday.cases_on d monday tuesday wednesday thursday friday saturday sunday

  definition previous (d : weekday) : weekday :=
  weekday.cases_on d saturday sunday monday tuesday wednesday thursday friday

  theorem next_previous (d: weekday) : next (previous d) = d :=
  weekday.induction_on d
    (show next (previous sunday) = sunday, from rfl)
    (show next (previous monday) = monday, from rfl)
    (show next (previous tuesday) = tuesday, from rfl)
    (show next (previous wednesday) = wednesday, from rfl)
    (show next (previous thursday) = thursday, from rfl)
    (show next (previous friday) = friday, from rfl)
    (show next (previous saturday) = saturday, from rfl)
end weekday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In fact, <code>induction_on</code> is just a special case of <code>rec_on</code> where the
target type is an element of <code>Prop</code>. In other words, under the
propositions-as-types correspondence, the principle of induction is a
type of definition by recursion, where what is being "defined" is a
proof instead of a piece of data. We could equally well have used
<code>cases_on</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">  theorem next_previous (d: weekday) : next (previous d) = d :=
  weekday.cases_on d
    (show next (previous sunday) = sunday, from rfl)
    (show next (previous monday) = monday, from rfl)
    (show next (previous tuesday) = tuesday, from rfl)
    (show next (previous wednesday) = wednesday, from rfl)
    (show next (previous thursday) = thursday, from rfl)
    (show next (previous friday) = friday, from rfl)
    (show next (previous saturday) = saturday, from rfl)</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

namespace weekday
  definition next (d : weekday) : weekday :=
  weekday.cases_on d monday tuesday wednesday thursday friday saturday sunday

  definition previous (d : weekday) : weekday :=
  weekday.cases_on d saturday sunday monday tuesday wednesday thursday friday

  theorem next_previous (d: weekday) : next (previous d) = d :=
  weekday.cases_on d
    (show next (previous sunday) = sunday, from rfl)
    (show next (previous monday) = monday, from rfl)
    (show next (previous tuesday) = tuesday, from rfl)
    (show next (previous wednesday) = wednesday, from rfl)
    (show next (previous thursday) = thursday, from rfl)
    (show next (previous friday) = friday, from rfl)
    (show next (previous saturday) = saturday, from rfl)
end weekday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>
<p>
While the <code>show</code> commands make the proof clearer and more
readable, they are not necessary:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">  theorem next_previous (d: weekday) : next (previous d) = d :=
  weekday.cases_on d rfl rfl rfl rfl rfl rfl rfl</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>inductive weekday : Type :=
| sunday : weekday
| monday : weekday
| tuesday : weekday
| wednesday : weekday
| thursday : weekday
| friday : weekday
| saturday : weekday

namespace weekday
  definition next (d : weekday) : weekday :=
  weekday.cases_on d monday tuesday wednesday thursday friday saturday sunday

  definition previous (d : weekday) : weekday :=
  weekday.cases_on d saturday sunday monday tuesday wednesday thursday friday

  theorem next_previous (d: weekday) : next (previous d) = d :=
  weekday.cases_on d rfl rfl rfl rfl rfl rfl rfl
end weekday
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Some fundamental data types in the Lean library are instances of
enumerated types.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">inductive empty : Type

inductive unit : Type :=
star : unit

inductive bool : Type :=
| ff : bool
| tt : bool</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>import standard

namespace hide

inductive empty : Type

inductive unit : Type :=
star : unit

inductive bool : Type :=
| ff : bool
| tt : bool

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
(To run these examples, we put them in a namespace called <code>hide</code>, so
that a name like <code>bool</code> does not conflict with the <code>bool</code> in the
standard library. This is necessary because these types are part of
the Lean "prelude" that is automatically imported with the system is
started.)
</p>

<p>
The type <code>empty</code> is an inductive datatype with no constructors. The
type <code>unit</code> has a single element, <code>star</code>, and the type <code>bool</code>
represents the familiar boolean values. As an exercise, you should
think about what the introduction and elimination rules for these
types do. As a further exercise, we suggest defining boolean
operations <code>band</code>, <code>bor</code>, <code>bnot</code> on the boolean, and verifying common
identities. Note that defining a binary operation like <code>band</code> will
require nested cases splits:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">definition band (b1 b2 : bool) : bool :=
bool.cases_on b1
  ff
  (bool.cases_on b2 ff tt)</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>import data.bool
open bool

namespace hide

definition band (b1 b2 : bool) : bool :=
bool.cases_on b1
  ff
  (bool.cases_on b2 ff tt)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Similarly, most identities can be proved by introducing suitable case
splits, and then using <code>rfl</code>.
</p>
</div>
</div>

<div id="outline-container-orgcb25af4" class="outline-3">
<h3 id="orgcb25af4"><span class="section-number-3"> 6.2</span> Constructors with Arguments</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Enumerated types are a very special case of inductive types, in which
the constructors take no arguments at all. In general, a
"construction" can depend on data, which is then represented in the
constructed argument. Consider the definitions of the product type and
sum type in the library:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">inductive prod (A B : Type) :=
mk : A → B → prod A B

inductive sum (A B : Type) : Type :=
| inl {} : A → sum A B
| inr {} : B → sum A B</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>namespace hide

inductive prod (A B : Type) :=
mk : A → B → prod A B

inductive sum (A B : Type) : Type :=
| inl {} : A → sum A B
| inr {} : B → sum A B

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
<p>
For the moment, ignore the annotation <code>{}</code> after the constructors
<code>inl</code> and <code>inr</code>; we will explain that below. In the meanwhile, think
about what is going on in these examples. The product type has one
constructor, <code>prod.mk</code>, which takes two arguments. To define a
function on <code>prod A B</code>, we can assume the input is of the form <code>prod.mk a
b</code>, and we have to specify the output, in terms of <code>a</code> and <code>b</code>. We can
use this to define the two projections for prod; remember that the
standard library defines notation <code>A × B</code> for <code>prod A B</code> and <code>(a, b)</code>
for <code>prod.mk a b</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">definition pr1 {A B : Type} (p : A × B) : A :=
prod.rec_on p (λ a b, a)

definition pr2 {A B : Type} (p : A × B) : B :=
prod.rec_on p (λ a b, b)</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>import data.prod
open prod

namespace hide

definition pr1 {A B : Type} (p : A × B) : A :=
prod.rec_on p (λ a b, a)

definition pr2 {A B : Type} (p : A × B) : B :=
prod.rec_on p (λ a b, b)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The function <code>pr1</code> takes a pair, <code>p</code>. Applying the recursor
<code>prod.rec_on p (fun a b, a)</code> interprets <code>p</code> as a pair, <code>prod.mk a b</code>,
and then uses the second argument to determine what to do with <code>a</code> and
<code>b</code>.
</p>

<p>
Here is another example:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">definition prod_example (p : bool × ℕ) : ℕ :=
prod.rec_on p (λ b n, cond b (2 * n) (2 * n + 1))

eval prod_example (tt, 3)
eval prod_example (ff, 3)</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>import data.bool data.prod data.nat data.prod data.sum
open prod sum nat bool
definition prod_example (p : bool × ℕ) : ℕ :=
prod.rec_on p (λ b n, cond b (2 * n) (2 * n + 1))

eval prod_example (tt, 3)
eval prod_example (ff, 3)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The <code>cond</code> function is a boolean conditional: <code>cond b t1 t2</code> return
<code>t1</code> if <code>b</code> is true, and <code>t2</code> otherwise. (It has the same effect as
<code>bool.rec_on b t2 t1</code>.) The function <code>prod_example</code> takes a pair
consisting of a boolean, <code>b</code>, and a number, <code>n</code>, and returns either
<code>2 * n</code> or <code>2 * n + 1</code> according to whether <code>b</code> is true or false.
</p>

<p>
In contrast, the sum type has <i>two</i> constructors, <code>inl</code> and <code>inr</code> (for
"insert left" and "insert right"), each of which takes <i>one</i> (explicit)
argument. To define a function on <code>sum A B</code>, we have to handle two
cases: either the input is of the form <code>inl a</code>, in which case we have
to specify an output value in terms of <code>a</code>, or the input is of the
form <code>inr b</code>, in which case we have to specify an output value in
terms of <code>b</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">definition sum_example (s : ℕ + ℕ) : ℕ :=
sum.cases_on s (λ n, 2 * n) (λ n, 2 * n + 1)

eval sum_example (inl 3)
eval sum_example (inr 3)</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>import data.bool data.prod data.nat data.prod data.sum
open prod sum nat bool

definition sum_example (s : ℕ + ℕ) : ℕ :=
sum.cases_on s (λ n, 2 * n) (λ n, 2 * n + 1)

eval sum_example (inl 3)
eval sum_example (inr 3)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This example is similar to the previous one, but now an input to
<code>sum_example</code> is implicitly either of the form <code>inl n</code> or <code>inr n</code>. In
the first case, the function returns <code>2 * n</code>, and the second case, it
returns <code>2 * n + 1</code>.
</p>

<p>
In the section after next we will see what happens when the
constructor of an inductive type takes arguments from the inductive
type itself. What characterizes the examples we consider in this
section is that this is not the case: each constructor relies only on
previously specified types.
</p>

<p>
Notice that a type with multiple constructors is disjunctive: an
element of <code>sum A B</code> is either of the form <code>inl a</code> <i>or</i> of the form
<code>inl b</code>. A constructor with multiple arguments introduces conjunctive
information: from an element <code>prod.mk a b</code> of <code>prod A B</code> we can
extract <code>a</code> <i>and</i> <code>b</code>. An arbitrary inductive type can include both
features, by having any number of constructors, each of which takes
any number of arguments.
</p>

<p>
A type, like <code>prod</code>, with only one constructor is purely conjunctive:
the constructor simply packs the list of arguments into a single piece
of data, essentially a tuple where the type of subsequent arguments
can depend on the type of the initial argument. We can also think of
such a type as a "record" or a "structure". In Lean, these two words
are synonymous, and provide alternative syntax for inductive types
with a single constructor.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">structure prod (A B : Type) :=
mk :: (pr1 : A) (pr2 : B)</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>namespace hide

structure prod (A B : Type) :=
mk :: (pr1 : A) (pr2 : B)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The <code>structure</code> command simultaneously introduces the inductive type,
<code>prod</code>, its constructor, <code>mk</code>, the usual eliminators (<code>rec</code>,
<code>rec_on</code>), as well as the projections, <code>pr1</code> and <code>pr2</code>, as defined
above.
</p>

<p>
If you do not name the constructor, Lean uses <code>mk</code> as a
default. For example, the following defines a record to store a color
as a triple of RGB values:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">record color := (red : nat) (green : nat) (blue : nat)
definition yellow := color.mk 255 255 0
eval color.red yellow</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>open nat

record color := (red : nat) (green : nat) (blue : nat)
definition yellow := color.mk 255 255 0
eval color.red yellow
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The definition of <code>yellow</code> forms the record with the three values
shown, and the projection <code>color.red</code> returns the red component. The
<code>structure</code> command is especially useful for defining algebraic
structures, and Lean provides substantial infrastructure to support
working with them. Here, for example, is the definition of a
semigroup:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">structure Semigroup : Type :=
(carrier : Type)
(mul : carrier → carrier → carrier)
(mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c))
</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>structure Semigroup : Type :=
(carrier : Type)
(mul : carrier → carrier → carrier)
(mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We will see more examples in Chapter <a href="#" onclick="myModule.loadTutorial('10_Structures_and_Records.html', 'Structures_and_Records')">Structures and Records</a>.
</p>

<p>
Notice that the product type depends on parameters <code>A B : Type</code> which
are arguments to the constructors as well as <code>prod</code>.  Lean detects
when these arguments can be inferred from later arguments to a
constructor, and makes them implicit in that case. Sometimes an
argument can only be inferred from the return type, which means that
it could not be inferred by parsing the expression from bottom up, but
may be inferrable from context. In that case, Lean does not make the
argument implicit by default, but will do so if we add the annotation
<code>{}</code> after the constructor. We used that option, for example, in the
definition of <code>sum</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-20' mode="ace/mode/lean" readonly="true">inductive sum (A B : Type) : Type :=
| inl {} : A → sum A B
| inr {} : B → sum A B</juicy-ace-editor><div id='lean-full-code-20' style='display:none'>namespace hide

inductive sum (A B : Type) : Type :=
| inl {} : A → sum A B
| inr {} : B → sum A B

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-20').text());">Try it yourself &raquo;</button></div>
</div>
<p>
As a result, the argument <code>A</code> to <code>inl</code> and the argument <code>B</code> to
<code>inr</code> are left implicit.
</p>

<p>
We have already discussed sigma types, also known as the dependent
product:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-21' mode="ace/mode/lean" readonly="true">inductive sigma {A : Type} (B : A → Type) :=
dpair : Π a : A, B a → sigma B</juicy-ace-editor><div id='lean-full-code-21' style='display:none'>namespace hide

inductive sigma {A : Type} (B : A → Type) :=
dpair : Π a : A, B a → sigma B

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-21').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Two more examples of inductive types in the library are the
following:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-22' mode="ace/mode/lean" readonly="true">inductive option (A : Type) : Type :=
| none {} : option A
| some    : A → option A

inductive inhabited (A : Type) : Type :=
mk : A → inhabited A</juicy-ace-editor><div id='lean-full-code-22' style='display:none'>namespace hide

inductive option (A : Type) : Type :=
| none {} : option A
| some    : A → option A

inductive inhabited (A : Type) : Type :=
mk : A → inhabited A

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-22').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In the semantics of dependent type theory, there is no built-in notion
of a partial function. Every element of a function type <code>A → B</code> or a
Pi type <code>Π x : A, B</code> is assumed to have a value at every input. The
<code>option</code> type provides a way of representing partial functions. An
element of <code>option B</code> is either <code>none</code> or of the form <code>some b</code>, for
some value <code>b : B</code>. Thus we can think of an element <code>f</code> of the type <code>A
→ option B</code> as being a partial function from <code>A</code> to <code>B</code>: for every
<code>a : A</code>, <code>f a</code> either returns <code>none</code>, indicating the <code>f a</code> is
"undefined", or <code>some b</code>.
</p>

<p>
An element of <code>inhabited A</code> is simply a witness to the fact that there
is an element of <code>A</code>. Later, we will see that <code>inhabited</code> is an
example of a <i>type class</i> in Lean: Lean can be instructed that
suitable base types are inhabited, and can automatically infer that
other constructed types are inhabited on that basis.
</p>

<p>
As exercises, we encourage you to develop a notion of composition for
partial functions from <code>A</code> to <code>B</code> and <code>B</code> to <code>C</code>, and show that it
behaves as expected. We also encourage you to show that <code>bool</code> and
<code>nat</code> are inhabited, that the product of two inhabited types is
inhabited, and that the type of functions to an inhabited type is
inhabited.
</p>
</div>
</div>

<div id="outline-container-org6490a54" class="outline-3">
<h3 id="org6490a54"><span class="section-number-3"> 6.3</span> Inductively Defined Propositions</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Inductively defined types can live in any type universe, including the
bottom-most one, <code>Prop</code>. In fact, this is exactly how the logical
connectives are defined.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-23' mode="ace/mode/lean" readonly="true">inductive false : Prop

inductive true : Prop :=
intro : true

inductive and (a b : Prop) : Prop :=
intro : a → b → and a b

inductive or (a b : Prop) : Prop :=
| intro_left  : a → or a b
| intro_right : b → or a b</juicy-ace-editor><div id='lean-full-code-23' style='display:none'>namespace hide

inductive false : Prop

inductive true : Prop :=
intro : true

inductive and (a b : Prop) : Prop :=
intro : a → b → and a b

inductive or (a b : Prop) : Prop :=
| intro_left  : a → or a b
| intro_right : b → or a b

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-23').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You should think about how these give rise to the introduction and
elimination rules that you have already seen. There are rules that
govern what the eliminator of an inductive type can eliminate <i>to</i>,
that is, what kinds of types can be the target of a recursor. Roughly
speaking, what characterizes inductive types in <code>Prop</code> is that one can
only eliminate to other types in <code>Prop</code>. This is consistent with the
understanding that if <code>P : Prop</code>, an element <code>p : P</code> carries no
data. There is a small exception to this rule, however, which we will
discuss below, in the section on inductive families.
</p>

<p>
Even the existential quantifier is inductively defined:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-24' mode="ace/mode/lean" readonly="true">inductive Exists {A : Type} (P : A → Prop) : Prop :=
intro : ∀ (a : A), P a → Exists P

definition exists.intro := @Exists.intro</juicy-ace-editor><div id='lean-full-code-24' style='display:none'>namespace hide

inductive Exists {A : Type} (P : A → Prop) : Prop :=
intro : ∀ (a : A), P a → Exists P

definition exists.intro := @Exists.intro

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-24').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Keep in mind that the notation <code>∃ x : A, P</code> is syntactic sugar for
<code>Exists (λ x : A, P)</code>.
</p>

<p>
The definitions of <code>false</code>, <code>true</code>, <code>and</code>, and <code>or</code> are perfectly
analogous to the definitions of <code>empty</code>, <code>unit</code>, <code>prod</code>, and
<code>sum</code>. The difference is that the first group yields elements of
<code>Prop</code>, and the second yields elements of <code>Type.{i}</code> for <code>i</code> greater
than 0. In a similar way, <code>∃ x : A, P</code> is a <code>Prop</code>-valued variant of
<code>Σ x : A, P</code>.
</p>

<p>
This is a good place to mention another inductive type, denoted <code>{x :
A | P}</code>, which is sort of a hybrid between <code>∃ x : A, P</code> and <code>Σ x : A, P</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-25' mode="ace/mode/lean" readonly="true">inductive subtype {A : Type} (P : A → Prop) : Type :=
tag : Π x : A, P x → subtype P</juicy-ace-editor><div id='lean-full-code-25' style='display:none'>namespace hide

inductive subtype {A : Type} (P : A → Prop) : Type :=
tag : Π x : A, P x → subtype P

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-25').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The notation <code>{x : A | P}</code> is syntactic sugar for <code>subtype (λ x : A,
P)</code>. It is modeled after subset notation in set theory: the idea is
that <code>{x : A | P}</code> denotes the collection of elements of <code>A</code> that have
property <code>P</code>.
</p>
</div>
</div>

<div id="outline-container-org23f3690" class="outline-3">
<h3 id="org23f3690"><span class="section-number-3"> 6.4</span> Defining the Natural Numbers</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The inductively defined types we have seen so far are "flat":
constructors wrap data and insert it into a type, and the
corresponding recursor unpacks the data and acts on it. Things get
much more interesting when the constructors act on elements of the
very type being defined. A canonical example is the type <code>nat</code> of
natural numbers:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-26' mode="ace/mode/lean" readonly="true">inductive nat : Type :=
| zero : nat
| succ : nat → nat</juicy-ace-editor><div id='lean-full-code-26' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-26').text());">Try it yourself &raquo;</button></div>
</div>
<p>
There are two constructors. We start with <code>zero : nat</code>; it takes no
arguments, so we have it from the start. In contrast, the constructor
<code>succ</code> can only be applied to a previously constructed <code>nat</code>. Applying
it to <code>zero</code> yields <code>succ zero : nat</code>. Applying it again yields <code>succ
(succ zero) : nat</code>, and so on. Intuitively, <code>nat</code> is the "smallest"
type with these constructors, meaning that it is exhaustively (and
freely) generated by starting with <code>zero</code> and applying <code>succ</code>
repeatedly.
</p>

<p>
As before, the recursor for <code>nat</code> is designed to define a dependent
function <code>f</code> from <code>nat</code> to any domain, that is, an element <code>f</code> of
<code>Π n : nat, C n</code> for some <code>C : nat → Type</code>. It has to handle two cases:
the case where the input is <code>zero</code>, and the case where the input is
of the form <code>succ n</code> for some <code>n : nat</code>. In the first case, we simply
specify a target value with the appropriate type, as before. In the
second case, however, the recursor can assume that a value of <code>f</code> at
<code>n</code> has already been computed. As a result, the next argument to the
recursor specifies a value for <code>f (succ n)</code> in terms of <code>n</code> and <code>f
n</code>. If we check the type of the recursor,
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-27' mode="ace/mode/lean" readonly="true">check @nat.rec_on</juicy-ace-editor><div id='lean-full-code-27' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat
check @nat.rec_on

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-27').text());">Try it yourself &raquo;</button></div>
</div>
<p>
we find the following:
</p>
<div class="org-src-container">

<pre class="src src-text">  &#928; {C : nat &#8594; Type} (n : nat),
    C nat.zero &#8594; (&#928; (a : nat), C a &#8594; C (nat.succ a)) &#8594; C n
</pre>
</div>
<p>
The implicit argument, <code>C</code>, is the codomain of the function being
defined. In type theory it is common to say <code>C</code> is the <code>motive</code> for
the elimination/recursion.  The next argument, <code>n : nat</code>, is the input
to the function. It is also known as the <code>major premise</code>. Finally, the
two arguments after specify how to compute the zero and successor
cases, as described above. They are also known as the <code>minor
premises</code>.
</p>

<p>
Consider, for example, the addition function <code>add m n</code> on the natural
numbers. Fixing <code>m</code>, we can define addition by recursion on <code>n</code>. In
the base case, we set <code>add m zero</code> to <code>m</code>. In the successor step,
assuming the value <code>add m n</code> is already determined, we define <code>add m
(succ n)</code> to be <code>succ (add m n)</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-29' mode="ace/mode/lean" readonly="true">namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (λ n add_m_n, succ add_m_n)

-- try it out
eval add (succ zero) (succ (succ zero))

end nat</juicy-ace-editor><div id='lean-full-code-29' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat
namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (λ n add_m_n, succ add_m_n)

-- try it out
eval add (succ zero) (succ (succ zero))

end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-29').text());">Try it yourself &raquo;</button></div>
</div>

<p>
It is useful to put such definitions into a namespace, <code>nat</code>. We can
then go on to define familiar notation in that namespace. The two
defining equations for addition now hold definitionally:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-30' mode="ace/mode/lean" readonly="true">notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl
theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl</juicy-ace-editor><div id='lean-full-code-30' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (fun n add_m_n, succ add_m_n)
notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl
theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl
end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-30').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Proving a fact like <code>0 + m = m</code>, however, requires a proof by
induction. As observed above, the induction principle is just a
special case of the recursion principle, when the codomain <code>C n</code> is an
element of <code>Prop</code>. It represents the familiar pattern of an inductive
proof: to prove <code>∀ n, C n</code>, first prove <code>C 0</code>, and then, for arbitrary
<code>n</code>, assume <code>IH : C n</code> and prove <code>C (succ n)</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-31' mode="ace/mode/lean" readonly="true">local abbreviation induction_on := @nat.induction_on

theorem zero_add (n : nat) : 0 + n = n :=
induction_on n
  (show 0 + 0 = 0, from rfl)
  (take n,
    assume IH : 0 + n = n,
    show 0 + succ n = succ n, from
      calc
        0 + succ n = succ (0 + n) : rfl
          ... = succ n : IH)</juicy-ace-editor><div id='lean-full-code-31' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (fun n add_m_n, succ add_m_n)

notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl
theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl
local abbreviation induction_on := @nat.induction_on

theorem zero_add (n : nat) : 0 + n = n :=
induction_on n
  (show 0 + 0 = 0, from rfl)
  (take n,
    assume IH : 0 + n = n,
    show 0 + succ n = succ n, from
      calc
        0 + succ n = succ (0 + n) : rfl
          ... = succ n : IH)
end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-31').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In the example above, we encourage you to replace <code>induction_on</code> with
<code>rec_on</code> and observe that the theorem is still accepted by Lean. As we
have seen above, <code>induction_on</code> is just a special case of <code>rec_on</code>.
</p>

<p>
For another example, let us prove the associativity of addition, <code>∀ m n
k, m + n + k = m + (n + k)</code>. (The notation <code>+</code>, as we have defined it,
associates to the left, so <code>m + n + k</code> is really <code>(m + n) + k</code>.) The
hardest part is figuring out which variable to do the induction
on. Since addition is defined by recursion on the second argument, <code>k</code>
is a good guess, and once we make that choice the proof almost writes
itself:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-32' mode="ace/mode/lean" readonly="true">theorem add_assoc (m n k : nat) : m + n + k = m + (n + k) :=
induction_on k
  (show m + n + 0 = m + (n + 0), from rfl)
  (take k,
    assume IH : m + n + k = m + (n + k),
    show m + n + succ k = m + (n + succ k), from
      calc
        m + n + succ k = succ (m + n + k) : rfl
          ... = succ (m + (n + k)) : IH
          ... = m + succ (n + k) : rfl
          ... = m + (n + succ k) : rfl)</juicy-ace-editor><div id='lean-full-code-32' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (fun n add_m_n, succ add_m_n)

notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl
theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl

local abbreviation induction_on := @nat.induction_on

theorem zero_add (n : nat) : 0 + n = n :=
induction_on n
  (show 0 + 0 = 0, from rfl)
  (take n,
    assume IH : 0 + n = n,
    show 0 + succ n = succ n, from
      calc
        0 + succ n = succ (0 + n) : rfl
          ... = succ n : IH)

theorem add_assoc (m n k : nat) : m + n + k = m + (n + k) :=
induction_on k
  (show m + n + 0 = m + (n + 0), from rfl)
  (take k,
    assume IH : m + n + k = m + (n + k),
    show m + n + succ k = m + (n + succ k), from
      calc
        m + n + succ k = succ (m + n + k) : rfl
          ... = succ (m + (n + k)) : IH
          ... = m + succ (n + k) : rfl
          ... = m + (n + succ k) : rfl)
end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-32').text());">Try it yourself &raquo;</button></div>
</div>

<p>
For another example, suppose we try to prove the commutativity of
addition. Choosing induction on the second argument, we might begin as
follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-33' mode="ace/mode/lean" readonly="true">theorem add_comm (m n : nat) : m + n = n + m :=
induction_on n
  (show m + 0 = 0 + m, from eq.symm (zero_add m))
  (take n,
    assume IH : m + n = n + m,
    calc
      m + succ n = succ (m + n) : rfl
        ... = succ (n + m) : IH
        ... = succ n + m : sorry)</juicy-ace-editor><div id='lean-full-code-33' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (fun n add_m_n, succ add_m_n)

notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl
theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl

local abbreviation induction_on := @nat.induction_on

theorem zero_add (n : nat) : 0 + n = n :=
induction_on n
  (show 0 + 0 = 0, from rfl)
  (take n,
    assume IH : 0 + n = n,
    show 0 + succ n = succ n, from
      calc
        0 + succ n = succ (0 + n) : rfl
          ... = succ n : IH)

attribute add [reducible]
theorem add_assoc (m n k : nat) : m + n + k = m + (n + k) :=
induction_on k rfl (fun k IH, eq.subst IH rfl)

theorem add_comm (m n : nat) : m + n = n + m :=
induction_on n
  (show m + 0 = 0 + m, from eq.symm (zero_add m))
  (take n,
    assume IH : m + n = n + m,
    calc
      m + succ n = succ (m + n) : rfl
        ... = succ (n + m) : IH
        ... = succ n + m : sorry)
end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-33').text());">Try it yourself &raquo;</button></div>
</div>
<p>
At this point, we see that we need another supporting fact, namely,
that <code>succ (n + m) = succ n + m</code>. We can prove this by induction on
<code>m</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-34' mode="ace/mode/lean" readonly="true">theorem succ_add (m n : nat) : succ m + n = succ (m + n) :=
induction_on n
  (show succ m + 0 = succ (m + 0), from rfl)
  (take n,
    assume IH : succ m + n = succ (m + n),
    show succ m + succ n = succ (m + succ n), from
      calc
        succ m + succ n = succ (succ m + n) : rfl
          ... = succ (succ (m + n)) : IH
          ... = succ (m + succ n) : rfl)</juicy-ace-editor><div id='lean-full-code-34' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (fun n add_m_n, succ add_m_n)

notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl
theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl

local abbreviation induction_on := @nat.induction_on

theorem zero_add (n : nat) : 0 + n = n :=
induction_on n
  (show 0 + 0 = 0, from rfl)
  (take n,
    assume IH : 0 + n = n,
    show 0 + succ n = succ n, from
      calc
        0 + succ n = succ (0 + n) : rfl
          ... = succ n : IH)

attribute add [reducible]
theorem add_assoc (m n k : nat) : m + n + k = m + (n + k) :=
induction_on k rfl (take k IH, eq.subst IH rfl)

theorem succ_add (m n : nat) : succ m + n = succ (m + n) :=
induction_on n
  (show succ m + 0 = succ (m + 0), from rfl)
  (take n,
    assume IH : succ m + n = succ (m + n),
    show succ m + succ n = succ (m + succ n), from
      calc
        succ m + succ n = succ (succ m + n) : rfl
          ... = succ (succ (m + n)) : IH
          ... = succ (m + succ n) : rfl)
end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-34').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can then replace the <code>sorry</code> in the previous proof with <code>succ_add</code>.
</p>

<p>
As an exercise, try defining other operations on the natural numbers,
such as multiplication, the predecessor function (with <code>pred 0 = 0</code>),
truncated subtraction (with <code>n - m = 0</code> when <code>m</code> is greater than or
equal to <code>n</code>), and exponentiation. Then try proving some of their
basic properties, building on the theorems we have already proved.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-35' mode="ace/mode/lean" readonly="true">-- define mul by recursion on the second argument
definition mul (m n : nat) : nat := sorry

infix `*` := mul

-- these should be proved by rfl
theorem mul_zero (m : nat) : m * 0 = 0 := sorry
theorem mul_succ (m n : nat) : m * (succ n) = m * n + m := sorry

theorem zero_mul (n : nat) : 0 * n = 0 := sorry

theorem mul_distrib (m n k : nat) : m * (n + k) = m * n + m * k := sorry

theorem mul_assoc (m n k : nat) : m * n * k = m * (n * k) := sorry

-- hint: you will need to prove an auxiliary statement
theorem mul_comm (m n : nat) : m * n = n * m := sorry

definition pred (n : nat) : nat := nat.cases_on n zero (fun n, n)

theorem pred_succ (n : nat) : pred (succ n) = n := sorry

theorem succ_pred (n : nat) : n ≠ 0 → succ (pred n) = n := sorry</juicy-ace-editor><div id='lean-full-code-35' style='display:none'>namespace hide

inductive nat : Type :=
| zero : nat
| succ : nat → nat

namespace nat

definition add (m n : nat) : nat :=
nat.rec_on n m (fun n add_m_n, succ add_m_n)

notation 0 := zero
infix `+` := add

theorem add_zero (m : nat) : m + 0 = m := rfl

theorem add_succ (m n : nat) : m + succ n = succ (m + n) := rfl

local abbreviation induction_on := @nat.induction_on

theorem zero_add (n : nat) : 0 + n = n :=
induction_on n
  (show 0 + 0 = 0, from rfl)
  (take n,
    assume IH : 0 + n = n,
    show 0 + succ n = succ n, from
      calc
        0 + succ n = succ (0 + n) : rfl
          ... = succ n : IH)

attribute add [reducible]
theorem add_assoc (m n k : nat) : m + n + k = m + (n + k) :=
induction_on k rfl (take k IH, eq.subst IH rfl)

theorem succ_add (m n : nat) : succ m + n = succ (m + n) :=
induction_on n
  (show succ m + 0 = succ (m + 0), from rfl)
  (take n,
    assume IH : succ m + n = succ (m + n),
    show succ m + succ n = succ (m + succ n), from
      calc
        succ m + succ n = succ (succ m + n) : rfl
          ... = succ (succ (m + n)) : IH
          ... = succ (m + succ n) : rfl)

theorem add_comm (m n : nat) : m + n = n + m :=
induction_on n
  (show m + 0 = 0 + m, from eq.symm (zero_add m))
  (take n,
    assume IH : m + n = n + m,
    calc
      m + succ n = succ (m + n) : rfl
        ... = succ (n + m) : IH
        ... = succ n + m : succ_add)

-- define mul by recursion on the second argument
definition mul (m n : nat) : nat := sorry

infix `*` := mul

-- these should be proved by rfl
theorem mul_zero (m : nat) : m * 0 = 0 := sorry
theorem mul_succ (m n : nat) : m * (succ n) = m * n + m := sorry

theorem zero_mul (n : nat) : 0 * n = 0 := sorry

theorem mul_distrib (m n k : nat) : m * (n + k) = m * n + m * k := sorry

theorem mul_assoc (m n k : nat) : m * n * k = m * (n * k) := sorry

-- hint: you will need to prove an auxiliary statement
theorem mul_comm (m n : nat) : m * n = n * m := sorry

definition pred (n : nat) : nat := nat.cases_on n zero (fun n, n)

theorem pred_succ (n : nat) : pred (succ n) = n := sorry

theorem succ_pred (n : nat) : n ≠ 0 → succ (pred n) = n := sorry
end nat

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-35').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org09f20ad" class="outline-3">
<h3 id="org09f20ad"><span class="section-number-3"> 6.5</span> Other Inductive Types</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Let us consider some more examples of inductively defined
types. For any type, <code>A</code>, the type <code>list A</code> of lists of elements
of <code>A</code> is defined in the library.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-36' mode="ace/mode/lean" readonly="true">inductive list (A : Type) : Type :=
| nil {} : list A
| cons : A → list A → list A

namespace list

variable {A : Type}

notation h :: t  := cons h t

definition append (s t : list A) : list A :=
list.rec t (λ x l u, x::u) s

notation s ++ t := append s t

theorem nil_append (t : list A) : nil ++ t = t := rfl

theorem cons_append (x : A) (s t : list A) : x::s ++ t = x::(s ++ t) := rfl

end list</juicy-ace-editor><div id='lean-full-code-36' style='display:none'>namespace hide
inductive list (A : Type) : Type :=
| nil {} : list A
| cons : A → list A → list A

namespace list

variable {A : Type}

notation h :: t  := cons h t

definition append (s t : list A) : list A :=
list.rec t (λ x l u, x::u) s

notation s ++ t := append s t

theorem nil_append (t : list A) : nil ++ t = t := rfl

theorem cons_append (x : A) (s t : list A) : x::s ++ t = x::(s ++ t) := rfl

end list
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-36').text());">Try it yourself &raquo;</button></div>
</div>
<p>
A list of elements of type <code>A</code> is either the empty list, <code>nil</code>, or an
element <code>h : A</code> followed by a list <code>t : list A</code>. We define the
notation <code>h :: t</code> to represent the latter. The first element, <code>h</code>, is
commonly known as the "head" of the list, and the remainder, <code>t</code>, is
known as the "tail." Recall that the notation <code>{}</code> in the definition of
the inductive type ensures that the argument to <code>nil</code> is implicit. In
most cases, it can be inferred from context. When it cannot, we have to
write <code>@nil A</code> to specify the type <code>A</code>.
</p>

<p>
Lean allows us to define iterative notation for lists:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-37' mode="ace/mode/lean" readonly="true">inductive list (A : Type) : Type :=
| nil {} : list A
| cons : A → list A → list A

namespace list

notation `[` l:(foldr `,` (h t, cons h t) nil) `]` := l

section
  open nat
  check [1, 2, 3, 4, 5]
  check ([1, 2, 3, 4, 5] : list ℕ)
end

end list</juicy-ace-editor><div id='lean-full-code-37' style='display:none'>namespace hide

inductive list (A : Type) : Type :=
| nil {} : list A
| cons : A → list A → list A

namespace list

notation `[` l:(foldr `,` (h t, cons h t) nil) `]` := l

section
  open nat
  check [1, 2, 3, 4, 5]
  check ([1, 2, 3, 4, 5] : list ℕ)
end

end list

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-37').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In the first <code>check</code>, Lean assumes that <code>[1, 2, 3, 4, 5]</code> is merely a
list of numerals. The <code>(t : list ℕ)</code> expression forces Lean to interpret <code>t</code> as
a list of natural numbers.
</p>

<p>
As an exercise, prove the following:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-38' mode="ace/mode/lean" readonly="true">theorem append_nil (t : list A) : t ++ nil = t := sorry

theorem append_assoc (r s t : list A) : r ++ s ++ t = r ++ (s ++ t) := sorry</juicy-ace-editor><div id='lean-full-code-38' style='display:none'>namespace hide

inductive list (A : Type) : Type :=
| nil {} : list A
| cons : A → list A → list A

namespace list

notation `[` l:(foldr `,` (h t, cons h t) nil) `]` := l

variable {A : Type}

notation h :: t  := cons h t

definition append (s t : list A) : list A :=
list.rec_on s t (λ x l u, x::u)

notation s ++ t := append s t

theorem nil_append (t : list A) : nil ++ t = t := rfl

theorem cons_append (x : A) (s t : list A) : x::s ++ t = x::(s ++ t) := rfl

theorem append_nil (t : list A) : t ++ nil = t := sorry

theorem append_assoc (r s t : list A) : r ++ s ++ t = r ++ (s ++ t) := sorry

end list

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-38').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Try also defining the function <code>length : Π A : Type, list A → nat</code>
that returns the length of a list, and prove that it behaves as
expected (for example, <code>length (s ++ t) = length s + length t</code>).
</p>

<p>
For another example, we can define the type of binary trees:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-39' mode="ace/mode/lean" readonly="true">inductive binary_tree :=
| leaf : binary_tree
| node : binary_tree → binary_tree → binary_tree
</juicy-ace-editor><div id='lean-full-code-39' style='display:none'>inductive binary_tree :=
| leaf : binary_tree
| node : binary_tree → binary_tree → binary_tree
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-39').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In fact, we can even define the type of countably branching trees:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-40' mode="ace/mode/lean" readonly="true">import data.nat
open nat

inductive cbtree :=
| leaf : cbtree
| sup : (ℕ → cbtree) → cbtree

namespace cbtree

definition succ (t : cbtree) : cbtree :=
sup (λ n, t)

definition omega : cbtree :=
sup (nat.rec leaf (λ n t, succ t))

end cbtree
</juicy-ace-editor><div id='lean-full-code-40' style='display:none'>import data.nat
open nat

inductive cbtree :=
| leaf : cbtree
| sup : (ℕ → cbtree) → cbtree

namespace cbtree

definition succ (t : cbtree) : cbtree :=
sup (λ n, t)

definition omega : cbtree :=
sup (nat.rec leaf (λ n t, succ t))

end cbtree
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-40').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org48f9cab" class="outline-3">
<h3 id="org48f9cab"><span class="section-number-3"> 6.6</span> Generalizations</h3>
<div class="outline-text-3" id="text-1-6">
<p>
We now consider two generalizations of inductive types that
are sometimes useful. First, Lean supports <i>mutually defined inductive
types</i>. The idea is that we can define two (or more) inductive types
at the same time, where each one refers to the other.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-41' mode="ace/mode/lean" readonly="true">inductive tree (A : Type) : Type :=
| node : A → forest A → tree A
with forest : Type :=
| nil  : forest A
| cons : tree A → forest A → forest A
</juicy-ace-editor><div id='lean-full-code-41' style='display:none'>inductive tree (A : Type) : Type :=
| node : A → forest A → tree A
with forest : Type :=
| nil  : forest A
| cons : tree A → forest A → forest A
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-41').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In this example, a <code>tree</code> with elements labeled from <code>A</code> is of the
form <code>node a f</code>, where <code>a</code> is an element of <code>A</code> (the label), and <code>f</code> a
forest. At the same time, a <code>forest</code> of trees with elements labeled
from <code>A</code> is essentially defined to be a list of trees.
</p>

<p>
A more powerful generalization is given by the possibility of defining
inductive type <code>families</code>. There are indexed families of types defined
by a simultaneous induction of the following form:
</p>
<div class="org-src-container">

<pre class="src src-text">inductive foo : ... &#8594; Type :=
| constructor&#8321; : ... &#8594; foo ...
| constructor&#8322; : ... &#8594; foo ...
...
| constructor&#8345; : ... &#8594; foo ...
</pre>
</div>
<p>
In contrast to ordinary inductive definition, which construct an
element of <code>Type</code>, the more general version constructs a function
<code>... → Type</code>, where "<code>...</code>" denotes a sequence of argument types, also
known as <i>indices</i>. Each constructor then constructs an element of some
type in the family. One example is the definition of <code>vector A n</code>, the
type of vectors of elements of <code>A</code> of length <code>n</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-43' mode="ace/mode/lean" readonly="true">inductive vector (A : Type) : nat → Type :=
| nil {} : vector A zero
| cons   : Π {n}, A → vector A n → vector A (succ n)</juicy-ace-editor><div id='lean-full-code-43' style='display:none'>open nat
namespace hide

inductive vector (A : Type) : nat → Type :=
| nil {} : vector A zero
| cons   : Π {n}, A → vector A n → vector A (succ n)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-43').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that the <code>cons</code> constructor takes an element of <code>vector A n</code>,
and returns an element of <code>vector A (succ n)</code>, thereby using an
element of one member of the family to build an element of another.
</p>

<p>
Another example is given by the family of types <code>fin n</code>. For each <code>n</code>,
<code>fin n</code> is supposed to denote a generic type of <code>n</code> elements:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-44' mode="ace/mode/lean" readonly="true">inductive fin : nat → Type :=
| fz : Π n, fin (nat.succ n)
| fs : Π {n}, fin n → fin (nat.succ n)</juicy-ace-editor><div id='lean-full-code-44' style='display:none'>namespace hide

inductive fin : nat → Type :=
| fz : Π n, fin (nat.succ n)
| fs : Π {n}, fin n → fin (nat.succ n)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-44').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This example may be hard to understand, so you should take the time to
think about how it works.
</p>

<p>
Yet another example is given by the definition of the equality type in
the library:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-45' mode="ace/mode/lean" readonly="true">inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a</juicy-ace-editor><div id='lean-full-code-45' style='display:none'>namespace hide

inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-45').text());">Try it yourself &raquo;</button></div>
</div>
<p>
For each fixed <code>A : Type</code> and <code>a : A</code>, this definition constructs a
family of types <code>eq a x</code>, indexed by <code>x : A</code>. Notably, however, there
is only one constructor, <code>refl</code>, which is an element of <code>eq a
a</code>. Intuitively, the only way to construct a proof of <code>eq a x</code> is to
use reflexivity, in the case where <code>x</code> is <code>a</code>.  Note that <code>eq a a</code> is
the only inhabited type in the family of types <code>eq a x</code>.  The
elimination principle generated by Lean says that <code>eq</code> is the <i>least</i>
reflexive relation on <code>A</code>. The eliminator/recursor for <code>eq</code> is of the
following form:
</p>
<div class="org-src-container">

<pre class="src src-text">eq.rec_on : &#928; {A : Type} {a : A} {C : A &#8594; Type} {b : A}, a = b &#8594; C a &#8594; C b
</pre>
</div>
<p>
It is a remarkable fact that all the basic axioms for equality follow
from the constructor, <code>refl</code>, and the eliminator, <code>eq.rec_on</code>.
</p>

<p>
This eliminator illustrates the exception to the fact
that inductive definitions living in <code>Prop</code> can only eliminate to
<code>Prop</code>. Because there is only one constructor to <code>eq</code>, it carries no
information, other than the type is inhabited, and Lean's internal
logic allows us to eliminate to an arbitrary <code>Type</code>. This is how we
define a <i>cast</i> operation that casts an element from type <code>A</code> into <code>B</code>
when a proof <code>p : eq A B</code> is provided:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-47' mode="ace/mode/lean" readonly="true">theorem cast {A B : Type} (p : eq A B) (a : A) : B :=
eq.rec_on p a</juicy-ace-editor><div id='lean-full-code-47' style='display:none'>namespace hide

inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a

theorem cast {A B : Type} (p : eq A B) (a : A) : B :=
eq.rec_on p a

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-47').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The recursor <code>eq.rec_on</code> is also used to define substitution:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-48' mode="ace/mode/lean" readonly="true">theorem subst {A : Type} {a b : A} {P : A → Prop}
  (H₁ : eq a b) (H₂ : P a) : P b :=
eq.rec H₂ H₁</juicy-ace-editor><div id='lean-full-code-48' style='display:none'>namespace hide

inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a

theorem subst {A : Type} {a b : A} {P : A → Prop}
  (H₁ : eq a b) (H₂ : P a) : P b :=
eq.rec H₂ H₁

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-48').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Using the recursor with <code>H₁ : a = b</code>, we may assume <code>a</code> and <code>b</code> are
the same, in which case, <code>P b</code> and <code>P a</code> are the same.
</p>

<p>
It is not hard to prove that <code>eq</code> is symmetric and transitive.
In the following example, we prove <code>symm</code> and leave as exercise
the theorems <code>trans</code> and <code>congr</code> (congruence).
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-49' mode="ace/mode/lean" readonly="true">theorem symm {A : Type} {a b : A} (H : eq a b) : eq b a :=
subst H (eq.refl a)

theorem trans {A : Type} {a b c : A} (H₁ : eq a b) (H₂ : eq b c) : eq a c :=
sorry

theorem congr {A B : Type} {a b : A} (f : A → B) (H : eq a b) : eq (f a) (f b) :=
sorry</juicy-ace-editor><div id='lean-full-code-49' style='display:none'>namespace hide

inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a

theorem subst {A : Type} {a b : A} {P : A → Prop}
  (H₁ : eq a b) (H₂ : P a) : P b :=
eq.rec H₂ H₁

theorem symm {A : Type} {a b : A} (H : eq a b) : eq b a :=
subst H (eq.refl a)

theorem trans {A : Type} {a b c : A} (H₁ : eq a b) (H₂ : eq b c) : eq a c :=
sorry

theorem congr {A B : Type} {a b : A} (f : A → B) (H : eq a b) : eq (f a) (f b) :=
sorry

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-49').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In the type theory literature, there are further generalizations of
inductive definitions, for example, the principles of
<i>induction-recursion</i> and <i>induction-induction</i>.  These are not
supported by Lean.
</p>
</div>
</div>

<div id="outline-container-org70956da" class="outline-3">
<h3 id="org70956da"><span class="section-number-3"> 6.7</span> Heterogeneous Equality</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Given <code>A : Type</code> and <code>B : A → Type</code>, suppose we want to generalize the
congruence theorem <code>congr</code> in the previous example to dependent
functions <code>f : Π x : A, B x</code>. Roughly speaking, we would like to have
a theorem that, says that if <code>a = b</code>, then <code>f a = f b</code>. The first
obstacle is stating the theorem: the term <code>eq (f a) (f b)</code> is not type
correct since <code>f a</code> has type <code>B a</code>, <code>f b</code> has type <code>B b</code>, and the
equality predicate <code>eq</code> expects both arguments to have the same
type. Notice that <code>f a</code> has type <code>B a</code>, so the term <code>eq.rec_on H (f
a)</code> has type <code>B b</code>. You should think of <code>eq.rec_on H (f a)</code> as "<code>f a</code>,
viewed as an element of <code>B b</code>." We can then write <code>eq (eq.rec_on H (f a))
(f b)</code> to express that <code>f a</code> and <code>f b</code> are equal, modulo the
difference between their types. Here is a proof of the generalized
congruence theorem, with this approach:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-50' mode="ace/mode/lean" readonly="true">theorem hcongr {A : Type} {B : A → Type} {a b : A} (f : Π x : A, B x)
               (H : eq a b) : eq (eq.rec_on H (f a)) (f b) :=
have h₁ : ∀ h : eq a a, eq (eq.rec_on h (f a)) (f a), from
  assume h : eq a a, eq.refl (eq.rec_on h (f a)),
have h₂ : ∀ h : eq a b, eq (eq.rec_on h (f a)) (f b), from
  eq.rec_on H h₁,
show eq (eq.rec_on H (f a)) (f b), from
  h₂ H</juicy-ace-editor><div id='lean-full-code-50' style='display:none'>namespace hide

inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a

theorem hcongr {A : Type} {B : A → Type} {a b : A} (f : Π x : A, B x)
               (H : eq a b) : eq (eq.rec_on H (f a)) (f b) :=
have h₁ : ∀ h : eq a a, eq (eq.rec_on h (f a)) (f a), from
  assume h : eq a a, eq.refl (eq.rec_on h (f a)),
have h₂ : ∀ h : eq a b, eq (eq.rec_on h (f a)) (f b), from
  eq.rec_on H h₁,
show eq (eq.rec_on H (f a)) (f b), from
  h₂ H

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-50').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Another option is to define a <i>heterogeneous equality</i> <code>heq</code> that can
equate terms of different types, so that we can write <code>heq (f a) (f
b)</code> instead of <code>eq (eq.rec_on H (f a)) (f b)</code>. It is straightforward
to define such an equality in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-51' mode="ace/mode/lean" readonly="true">inductive heq {A : Type} (a : A) : Π {B : Type}, B → Prop :=
refl : heq a a</juicy-ace-editor><div id='lean-full-code-51' style='display:none'>namespace hide

inductive heq {A : Type} (a : A) : Π {B : Type}, B → Prop :=
refl : heq a a

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-51').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Moreover, given <code>a b : A</code>, we can prove <code>heq a b → eq a b</code> using proof
irrelevance.  This theorem is called <code>heq.to_eq</code> in the Lean standard
library. We can now state and prove <code>hcongr</code> using heterogeneous
equality. Note the proof is also more compact and easier to
understand.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-52' mode="ace/mode/lean" readonly="true">theorem hcongr {A : Type} {B : A → Type} {a b : A} (f : Π x : A, B x)
               (H : eq a b) : heq (f a) (f b) :=
eq.rec_on H (heq.refl (f a))</juicy-ace-editor><div id='lean-full-code-52' style='display:none'>namespace hide

inductive eq {A : Type} (a : A) : A → Prop :=
refl : eq a a

inductive heq {A : Type} (a : A) : Π {B : Type}, B → Prop :=
refl : heq a a

theorem hcongr {A : Type} {B : A → Type} {a b : A} (f : Π x : A, B x)
               (H : eq a b) : heq (f a) (f b) :=
eq.rec_on H (heq.refl (f a))

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-52').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Heterogeneous equality, which gives elements of different types the
illusion that they can be considered equal, is sometimes called <i>John
Major equality</i>. (The name is a bit of political humor, due to Conor
McBride.)
</p>
</div>
</div>

<div id="outline-container-org0bfb5b5" class="outline-3">
<h3 id="Automatically_Generated_Constructions"><a id="org0bfb5b5"></a><span class="section-number-3"> 6.8</span> Automatically Generated Constructions</h3>
<div class="outline-text-3" id="text-Automatically_Generated_Constructions">
<p>
In the previous sections, we have seen that whenever we declare an
inductive datatype <code>I</code>, the Lean kernel automatically declares its
constructors (aka introduction rules), and generates and declares the
eliminator/recursor <code>I.rec</code>. The eliminator expresses a principle of
definition by recursion, as well as the principle of proof by
induction. The kernel also associates a <i>computational rule</i> which
determines how these definitions are eliminated when terms and proofs
are normalized.
</p>

<p>
Consider, for example, the natural numbers. Given the motive <code>C : nat
→ Type</code>, and minor premises <code>fz : C zero</code> and <code>fs : Π (n : nat), C n →
C (succ n)</code>, we have the following two computational rules: <code>nat.rec
fz fs zero</code> reduces to <code>fz</code>, and <code>nat.rec fz fs (succ a)</code> reduces to
<code>fs a (nat.rec fz fs a)</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-53' mode="ace/mode/lean" readonly="true">open nat

variable C  : nat → Type
variable fz : C zero
variable fs : Π (n : nat), C n → C (succ n)

eval nat.rec fz fs zero
-- nat.rec_on is defined from nat.rec
eval nat.rec_on zero fz fs

example : nat.rec fz fs zero = fz :=
rfl

variable a : nat

eval nat.rec fz fs (succ a)
eval nat.rec_on (succ a) fz fs

example (a : nat) : nat.rec fz fs (succ a) = fs a (nat.rec fz fs a) :=
rfl
</juicy-ace-editor><div id='lean-full-code-53' style='display:none'>open nat

variable C  : nat → Type
variable fz : C zero
variable fs : Π (n : nat), C n → C (succ n)

eval nat.rec fz fs zero
-- nat.rec_on is defined from nat.rec
eval nat.rec_on zero fz fs

example : nat.rec fz fs zero = fz :=
rfl

variable a : nat

eval nat.rec fz fs (succ a)
eval nat.rec_on (succ a) fz fs

example (a : nat) : nat.rec fz fs (succ a) = fs a (nat.rec fz fs a) :=
rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-53').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The source code that validates an inductive declaration and generates
the eliminator/recursor and computational rules is part of the Lean
kernel. The kernel is also known as the <i>trusted code base</i>, because a
bug in the kernel may compromise the soundness of the whole system.
</p>

<p>
When you define an inductive datatype, Lean automatically generates a
number of useful definitions. We have already seen some of them:
<code>rec_on</code>, <code>induction_on</code>, and <code>cases_on</code>. The module <code>M</code> that
generates these definitions is <i>not</i> part of the trusted code base. A
bug in <code>M</code> does not compromise the soundness of the whole system,
since the kernel will catch such errors when type checking any
incorrectly generated definition produced by <code>M</code>.
</p>

<p>
As described before, <code>rec_on</code> just uses its arguments in a more
convenient order than <code>rec</code>. In <code>rec_on</code>, the major premise is
provided before the minor premises. Constructions using <code>rec_on</code> are
often easier to read and understand than the equivalent ones using
<code>rec</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-54' mode="ace/mode/lean" readonly="true">open nat

print definition nat.rec_on

definition rec_on {C : nat → Type} (n : nat)
                  (fz : C zero) (fs : Π a, C a → C (succ a)) : C n :=
nat.rec fz fs n
</juicy-ace-editor><div id='lean-full-code-54' style='display:none'>open nat

print definition nat.rec_on

definition rec_on {C : nat → Type} (n : nat)
                  (fz : C zero) (fs : Π a, C a → C (succ a)) : C n :=
nat.rec fz fs n
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-54').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Moreover, <code>induction_on</code> is just a special case of <code>rec_on</code> where the
motive <code>C</code> is a proposition. Finally, <code>cases_on</code> is a special case of
<code>rec_on</code> where the inductive/recursive hypotheses are omitted in the
minor premises. For example, in <code>nat.cases_on</code> the minor premise <code>fs</code>
has type <code>Π (n : nat), C (succ n)</code> instead of <code>Π (n : nat), C n → C
(succ n)</code>. Note that the inductive/recursive hypothesis <code>C n</code> has
been omitted.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-55' mode="ace/mode/lean" readonly="true">open nat

print definition nat.induction_on
print definition nat.cases_on

definition induction_on {C : nat → Prop} (n : nat)
                        (fz : C zero) (fs : Π a, C a → C (succ a)) : C n :=
nat.rec_on n fz fs

definition cases_on {C : nat → Prop} (n : nat)
                    (fz : C zero) (fs : Π a, C (succ a)) : C n :=
nat.rec_on n fz (fun (a : nat) (r : C a), fs a)</juicy-ace-editor><div id='lean-full-code-55' style='display:none'>namespace hide
open nat

print definition nat.induction_on
print definition nat.cases_on

definition induction_on {C : nat → Prop} (n : nat)
                        (fz : C zero) (fs : Π a, C a → C (succ a)) : C n :=
nat.rec_on n fz fs

definition cases_on {C : nat → Prop} (n : nat)
                    (fz : C zero) (fs : Π a, C (succ a)) : C n :=
nat.rec_on n fz (fun (a : nat) (r : C a), fs a)
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-55').text());">Try it yourself &raquo;</button></div>
</div>

<p>
For any inductive datatype that is not a proposition, we can show that
its constructors are injective and disjoint. For example, on <code>nat</code>, we
can show that <code>succ a = succ b → a = b</code> (injectivity), and <code>succ a ≠
zero</code> (disjointness). Both proofs can be performed using the
automatically generated definition <code>nat.no_confusion</code>. More generally,
for any inductive datatype <code>I</code> that is not a proposition, Lean
automatically generates a definition of <code>I.no_confusion</code>. Given a
motive <code>C</code> and an equality <code>h : c₁ t = c₂ s</code>, where <code>c₁</code> and <code>c₂</code> are
two distinct <code>I</code> constructors, <code>I.no_confusion</code> constructs an
inhabitant of <code>C</code>.  This is essentially the <i>principle of explosion</i>,
that is, the fact that anything follows from a contradiction. On the
other hand, given a proof of <code>c t = c s</code> with the same constructor on
both sides and a proof of <code>t = s → C</code>, <code>I.no_confusion</code> returns an
inhabitant of <code>C</code>.
</p>

<p>
Let us illustrate by considering the constructions for the type <code>nat</code>.
The type of <code>no_confusion</code> is based on the auxiliary definition
<code>no_confusion_type</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-56' mode="ace/mode/lean" readonly="true">open nat

check @nat.no_confusion
-- Π {P : Type} {v1 v2 : ℕ}, v1 = v2 → nat.no_confusion_type P v1 v2

check nat.no_confusion_type
-- Type → ℕ → ℕ → Type
</juicy-ace-editor><div id='lean-full-code-56' style='display:none'>open nat

check @nat.no_confusion
-- Π {P : Type} {v1 v2 : ℕ}, v1 = v2 → nat.no_confusion_type P v1 v2

check nat.no_confusion_type
-- Type → ℕ → ℕ → Type
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-56').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Note that the motive is an implicit argument in <code>no_confusion</code>. The
constructions work as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-57' mode="ace/mode/lean" readonly="true">variable C : Type
variables a b : nat

eval nat.no_confusion_type C zero     (succ a)
-- C
eval nat.no_confusion_type C (succ a) zero
-- C
eval nat.no_confusion_type C zero     zero
-- C → C
eval nat.no_confusion_type C (succ a) (succ b)
-- (a = b → C) → C</juicy-ace-editor><div id='lean-full-code-57' style='display:none'>open nat
variable C : Type
variables a b : nat

eval nat.no_confusion_type C zero     (succ a)
-- C
eval nat.no_confusion_type C (succ a) zero
-- C
eval nat.no_confusion_type C zero     zero
-- C → C
eval nat.no_confusion_type C (succ a) (succ b)
-- (a = b → C) → C
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-57').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In other words, from a proof of <code>zero = succ a</code> or <code>succ a = 0</code>, we
obtain an element of any type <code>C</code> at will. On the other hand, a proof
of <code>zero = zero</code> provides no help in constructing an element of type
<code>C</code>, whereas a proof of <code>succ a = succ b</code> reduces the task of
constructing an element of type <code>C</code> to the task of constructing such
an element under the additional hypothesis <code>a = b</code>.
</p>

<p>
It is not hard to prove that constructors are injective and disjoint
using <code>no_confusion</code>.  In the following example, we prove these two
properties for <code>nat</code> and leave as exercise the equivalent proofs for
trees.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-58' mode="ace/mode/lean" readonly="true">open nat

theorem succ_ne_zero (a : nat) (h : succ a = zero) : false :=
nat.no_confusion h

theorem succ.inj (a b : nat) (h : succ a = succ b) : a = b :=
nat.no_confusion h (fun e : a = b, e)

inductive tree (A : Type) : Type :=
| leaf : A → tree A
| node : tree A → tree A → tree A

open tree

variable {A : Type}

theorem leaf_ne_node {a : A} {l r : tree A}
                     (h : leaf a = node l r) : false :=
sorry

theorem leaf_inj {a b : A} (h : leaf a = leaf b) : a = b :=
sorry

theorem node_inj_left {l1 r1 l2 r2 : tree A}
                      (h : node l1 r1 = node l2 r2) : l1 = l2 :=
sorry

theorem node_inj_right {l1 r1 l2 r2 : tree A}
                       (h : node l1 r1 = node l2 r2) : r1 = r2 :=
sorry
</juicy-ace-editor><div id='lean-full-code-58' style='display:none'>open nat

theorem succ_ne_zero (a : nat) (h : succ a = zero) : false :=
nat.no_confusion h

theorem succ.inj (a b : nat) (h : succ a = succ b) : a = b :=
nat.no_confusion h (fun e : a = b, e)

inductive tree (A : Type) : Type :=
| leaf : A → tree A
| node : tree A → tree A → tree A

open tree

variable {A : Type}

theorem leaf_ne_node {a : A} {l r : tree A}
                     (h : leaf a = node l r) : false :=
sorry

theorem leaf_inj {a b : A} (h : leaf a = leaf b) : a = b :=
sorry

theorem node_inj_left {l1 r1 l2 r2 : tree A}
                      (h : node l1 r1 = node l2 r2) : l1 = l2 :=
sorry

theorem node_inj_right {l1 r1 l2 r2 : tree A}
                       (h : node l1 r1 = node l2 r2) : r1 = r2 :=
sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-58').text());">Try it yourself &raquo;</button></div>
</div>

<p>
If a constructor contains dependent arguments (such as <code>sigma.mk</code>),
the generated <code>no_confusion</code> uses heterogeneous equality to equate
arguments of different types:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-59' mode="ace/mode/lean" readonly="true">variables (A : Type) (B : A → Type)
variables (a1 a2 : A) (b1 : B a1) (b2 : B a2)
variable  (C : Type)

-- Remark: b1 and b2 have different types

eval sigma.no_confusion_type C (sigma.mk a1 b1) (sigma.mk a2 b2)
-- (a1 = a2 → b1 == b2 → C) → C
</juicy-ace-editor><div id='lean-full-code-59' style='display:none'>variables (A : Type) (B : A → Type)
variables (a1 a2 : A) (b1 : B a1) (b2 : B a2)
variable  (C : Type)

-- Remark: b1 and b2 have different types

eval sigma.no_confusion_type C (sigma.mk a1 b1) (sigma.mk a2 b2)
-- (a1 = a2 → b1 == b2 → C) → C
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-59').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Lean also generates the predicate transformer <code>below</code> and the recursor
<code>brec_on</code>. It is unlikely that you will ever need to use these
constructions directly; they are auxiliary definitions used by the
recursive equation compiler we will describe in the next chapter, and
we will not discuss them further here.
</p>
</div>
</div>

<div id="outline-container-org1adcc35" class="outline-3">
<h3 id="org1adcc35"><span class="section-number-3"> 6.9</span> Universe Levels</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Since an inductive type lives in <code>Type.{i}</code> for some <code>i</code>, it is
reasonable to ask <i>which</i> universe levels <code>i</code> can be instantiated
to. The goal of this section is to explain the relevant constraints.
</p>

<p>
In the standard library, there are two cases, depending on whether the
inductive type is specified to land in <code>Prop</code>. Let us first consider
the case where the inductive type is not specified to land in <code>Prop</code>,
which is the only case that arises in the homotopy type theory
instantiation of the kernel. Recall that each constructor <code>c</code> in the
definition of a family <code>C</code> of inductive types is of the form
</p>
<div class="org-src-container">

<pre class="src src-text">c : &#928; (a : A) (b : B[a]), C a p[a,b]
</pre>
</div>
<p>
where <code>a</code> is a sequence of datatype parameters, <code>b</code> is the sequence of
arguments to the constructors, and <code>p[a, b]</code> are the indices, which
determine which element of the inductive family the construction
inhabits. Then the universe level <code>i</code> of <code>C</code> is constrained to satisfy
the following:
</p>
<blockquote>
<p>
For each constructor <code>c</code> as above, and each <code>Bk[a]</code> in the sequence
<code>B[a]</code>, if <code>Bk[a] : Type.{j}</code>, we have <code>i</code> ≥ <code>j</code>.
</p>
</blockquote>
<p>
In other words, the universe level <code>i</code> is required to be at least as
large as the universe level of each type that represents an argument
to a constructor.
</p>

<p>
When the inductive type <code>C</code> is specified to land in <code>Prop</code>, there are
no constraints on the universe levels of the constructor
arguments. But these universe levels do have a bearing on the
elimination rule. Generally speaking, for an inductive type in <code>Prop</code>,
the motive of the elimination rule is required to be in <code>Prop</code>. The
exception we alluded to in the discussion of equality above is this:
we are allowed to eliminate to an arbitrary <code>Type</code> when there is only
one constructor, and each constructor argument is either in <code>Prop</code> or
an index. This exception, which makes it possible to treat ordinary
equality and heterogeneous equality as inductive types, can be
justified by the fact that the elimination rule cannot take advantage
of any "hidden" information.
</p>

<p>
Because inductive types can be polymorphic over universe levels,
whether an inductive definition lands in <code>Prop</code> could, in principle,
depend on how the universe levels are instantiated. To simplify the
generation of the recursors, Lean adopts a convention that rules out
this ambiguity: if you do not specify that the inductive type is an
element of <code>Prop</code>, Lean requires the universe level to be at least
one. Hence, a type specified by single inductive definition is either
always in <code>Prop</code> or never in <code>Prop</code>. For example, if <code>A</code> and <code>B</code> are
elements of <code>Prop</code>, <code>A × B</code> is assumed to have universe level at least
one, representing a datatype rather than a proposition. The analogous
definition of <code>A × B</code>, where <code>A</code> and <code>B</code> are restricted to <code>Prop</code> and
the resulting type is declared to be an element of <code>Prop</code> instead of
<code>Type</code>, is exactly the definition of <code>A ∧ B</code>.
</p>
<div id="bibliography">
<h2>References</h2>

<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="dybjer:94">1</a>]
</td>
<td class="bibtexitem">
Peter Dybjer.
 Inductive families.
 <em>Formal Asp. Comput.</em>, 6(4):440--465, 1994.
[&nbsp;<a href="lean_bib.html#dybjer:94">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/BF01211308">DOI</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/BF01211308">http</a>&nbsp;]

</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
